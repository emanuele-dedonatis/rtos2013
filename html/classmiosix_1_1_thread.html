<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>STM32F4 Pedometer: miosix::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">STM32F4 Pedometer
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A pedometer library for the STM32F4 Discovery board by ST Microelectronics.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemiosix.html">miosix</a></li><li class="navelem"><a class="el" href="classmiosix_1_1_thread.html">Thread</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmiosix_1_1_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">miosix::Thread Class Reference<div class="ingroups"><a class="el" href="group___kernel.html">Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="kernel_8h_source.html">kernel.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acaef68f0e93f6ad933442d87c210daaf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daaf">Options</a> { <a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa03df086cf889e215d75222d10486b71e">DEFAULT</a> =0, 
<a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa785d69b0e6b95b648735efe54b588df7">JOINABLE</a> =1&lt;&lt;0
 }</td></tr>
<tr class="separator:acaef68f0e93f6ad933442d87c210daaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aacba6298a092d5335f6dbefe56a611ec"><td class="memItemLeft" align="right" valign="top">Priority&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#aacba6298a092d5335f6dbefe56a611ec">getPriority</a> ()</td></tr>
<tr class="separator:aacba6298a092d5335f6dbefe56a611ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae086b5bf2b3b55972ad696ec820c8f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ae086b5bf2b3b55972ad696ec820c8f5e">terminate</a> ()</td></tr>
<tr class="separator:ae086b5bf2b3b55972ad696ec820c8f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19b8a2ab852ea771a2e2b95bb0ba2a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#af19b8a2ab852ea771a2e2b95bb0ba2a8">wakeup</a> ()</td></tr>
<tr class="separator:af19b8a2ab852ea771a2e2b95bb0ba2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88af678dc4032a5f92da12917947d881"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a88af678dc4032a5f92da12917947d881">PKwakeup</a> ()</td></tr>
<tr class="separator:a88af678dc4032a5f92da12917947d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7817dd59f317a04d3ce3793419d25a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ae7817dd59f317a04d3ce3793419d25a4">detach</a> ()</td></tr>
<tr class="separator:ae7817dd59f317a04d3ce3793419d25a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1d97df689c7104bec35858bbaf4ae6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#afb1d97df689c7104bec35858bbaf4ae6">isDetached</a> () const </td></tr>
<tr class="separator:afb1d97df689c7104bec35858bbaf4ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968b43a36ecdf124d72a5d8ddfa2a3b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a968b43a36ecdf124d72a5d8ddfa2a3b9">join</a> (void **<a class="el" href="classmiosix_1_1_thread.html#a448486b757b8ede4edaa8edc39962b17">result</a>=NULL)</td></tr>
<tr class="separator:a968b43a36ecdf124d72a5d8ddfa2a3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585c7966f59855aafd771c7733a38296"><td class="memItemLeft" align="right" valign="top">Priority&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a585c7966f59855aafd771c7733a38296">IRQgetPriority</a> ()</td></tr>
<tr class="separator:a585c7966f59855aafd771c7733a38296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34c3cbac8aa609a5c6e4abc384a9faa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ab34c3cbac8aa609a5c6e4abc384a9faa">IRQwakeup</a> ()</td></tr>
<tr class="separator:ab34c3cbac8aa609a5c6e4abc384a9faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac5a454f2617a4a28f00842b1097fc363"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ac5a454f2617a4a28f00842b1097fc363">create</a> (void *(*startfunc)(void *), unsigned int stacksize, Priority priority=Priority(), void *argv=NULL, unsigned short options=<a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa03df086cf889e215d75222d10486b71e">DEFAULT</a>)</td></tr>
<tr class="separator:ac5a454f2617a4a28f00842b1097fc363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d19634d30226cb4441a77b233a5bf2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a12d19634d30226cb4441a77b233a5bf2">create</a> (void(*startfunc)(void *), unsigned int stacksize, Priority priority=Priority(), void *argv=NULL, unsigned short options=<a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa03df086cf889e215d75222d10486b71e">DEFAULT</a>)</td></tr>
<tr class="separator:a12d19634d30226cb4441a77b233a5bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75823b1288a7defcb715fd6591a23b2d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a75823b1288a7defcb715fd6591a23b2d">yield</a> ()</td></tr>
<tr class="separator:a75823b1288a7defcb715fd6591a23b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef492878827009d2d55442266d13b99"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a0ef492878827009d2d55442266d13b99">testTerminate</a> ()</td></tr>
<tr class="separator:a0ef492878827009d2d55442266d13b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f738dc69a918960fe814a062696c5c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ad7f738dc69a918960fe814a062696c5c">sleep</a> (unsigned int ms)</td></tr>
<tr class="separator:ad7f738dc69a918960fe814a062696c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac116a322826366c7b3269db3ab4be73"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#aac116a322826366c7b3269db3ab4be73">sleepUntil</a> (long long absoluteTime)</td></tr>
<tr class="separator:aac116a322826366c7b3269db3ab4be73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884bfd106afeb274c339d383702b4aec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a884bfd106afeb274c339d383702b4aec">getCurrentThread</a> ()</td></tr>
<tr class="separator:a884bfd106afeb274c339d383702b4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb06c8f5761db66d1089a61db71dcf92"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#adb06c8f5761db66d1089a61db71dcf92">exists</a> (<a class="el" href="classmiosix_1_1_thread.html">Thread</a> *p)</td></tr>
<tr class="separator:adb06c8f5761db66d1089a61db71dcf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c4237506c533c00a0144632685b17d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#af6c4237506c533c00a0144632685b17d">setPriority</a> (Priority pr)</td></tr>
<tr class="separator:af6c4237506c533c00a0144632685b17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435fe4527c1fdfcbebf886cd748a3fd4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a435fe4527c1fdfcbebf886cd748a3fd4">wait</a> ()</td></tr>
<tr class="separator:a435fe4527c1fdfcbebf886cd748a3fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3918e86d91bbe3062f907004ba7f579"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ae3918e86d91bbe3062f907004ba7f579">IRQgetCurrentThread</a> ()</td></tr>
<tr class="separator:ae3918e86d91bbe3062f907004ba7f579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aed14f0f04e69f922aba8f0cf7ac0c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a6aed14f0f04e69f922aba8f0cf7ac0c6">IRQwait</a> ()</td></tr>
<tr class="separator:a6aed14f0f04e69f922aba8f0cf7ac0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572b87e4c6174ad4137f964e40bbe515"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a572b87e4c6174ad4137f964e40bbe515">IRQexists</a> (<a class="el" href="classmiosix_1_1_thread.html">Thread</a> *p)</td></tr>
<tr class="separator:a572b87e4c6174ad4137f964e40bbe515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c548e88ddd4ee0f555f1332e00d36af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c548e88ddd4ee0f555f1332e00d36af"></a>
static const unsigned int *&#160;</td><td class="memItemRight" valign="bottom"><b>getStackBottom</b> ()</td></tr>
<tr class="separator:a7c548e88ddd4ee0f555f1332e00d36af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645f06c3aacd91de8a620f9520b28a19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a645f06c3aacd91de8a620f9520b28a19"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>getStackSize</b> ()</td></tr>
<tr class="separator:a645f06c3aacd91de8a620f9520b28a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0299a51a8b97fb3200509d92ba10fa2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0299a51a8b97fb3200509d92ba10fa2c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Mutex</b></td></tr>
<tr class="separator:a0299a51a8b97fb3200509d92ba10fa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab270e49e575fdf0fe1a4f2ee911df116"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab270e49e575fdf0fe1a4f2ee911df116"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ConditionVariable</b></td></tr>
<tr class="separator:ab270e49e575fdf0fe1a4f2ee911df116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22ee38d5c5f8f0e8f6a4b4ac10f74e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af22ee38d5c5f8f0e8f6a4b4ac10f74e6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PriorityScheduler</b></td></tr>
<tr class="separator:af22ee38d5c5f8f0e8f6a4b4ac10f74e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59484a761a3671aa7a7955169aecd70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af59484a761a3671aa7a7955169aecd70"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ControlScheduler</b></td></tr>
<tr class="separator:af59484a761a3671aa7a7955169aecd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ebf1420d5ff18bb785abe0a8b247ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71ebf1420d5ff18bb785abe0a8b247ac"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>EDFScheduler</b></td></tr>
<tr class="separator:a71ebf1420d5ff18bb785abe0a8b247ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d12034b3fec16c639239e059894524"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50d12034b3fec16c639239e059894524"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CReentrancyAccessor</b></td></tr>
<tr class="separator:a50d12034b3fec16c639239e059894524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec53b1d1198012c3c7d28ba495f8b8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abec53b1d1198012c3c7d28ba495f8b8c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CppReentrancyAccessor</b></td></tr>
<tr class="separator:abec53b1d1198012c3c7d28ba495f8b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada350af94668c645cfe2f52d172da513"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada350af94668c645cfe2f52d172da513"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>miosix_private::IRQstackOverflowCheck</b> ()</td></tr>
<tr class="separator:ada350af94668c645cfe2f52d172da513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d27a24e1981da39a7e3c2535a65100"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40d27a24e1981da39a7e3c2535a65100"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IRQaddToSleepingList</b> (<a class="el" href="structmiosix_1_1_sleep_data.html">SleepData</a> *x)</td></tr>
<tr class="separator:a40d27a24e1981da39a7e3c2535a65100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198c0ce2b2ee1f076fae416f22100614"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a198c0ce2b2ee1f076fae416f22100614"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IRQwakeThreads</b> ()</td></tr>
<tr class="separator:a198c0ce2b2ee1f076fae416f22100614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9b5cd3ae98fecda0f20b1d15049cad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d9b5cd3ae98fecda0f20b1d15049cad"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>idleThread</b> (void *argv)</td></tr>
<tr class="separator:a3d9b5cd3ae98fecda0f20b1d15049cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2553567e64baf56df9a20ce1b777acf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2553567e64baf56df9a20ce1b777acf4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>startKernel</b> ()</td></tr>
<tr class="separator:a2553567e64baf56df9a20ce1b777acf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6682370c85e8fb1787a85388e91221f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6682370c85e8fb1787a85388e91221f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>miosix_private::initCtxsave</b> (unsigned int *ctxsave, void *(*pc)(void *), unsigned int *sp, void *argv)</td></tr>
<tr class="separator:a6682370c85e8fb1787a85388e91221f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a thread. It has methods for creating, deleting and handling threads.<br/>
It has private constructor and destructor, since memory for a thread is handled by the kernel.<br/>
To create a thread use the static producer method <a class="el" href="classmiosix_1_1_thread.html#ac5a454f2617a4a28f00842b1097fc363">create()</a>.<br/>
 Methods that have an effect on the current thread, that is, the thread that is calling the method are static.<br/>
 Calls to non static methods must be done with care, because a thread can terminate at any time. For example, if you call <a class="el" href="classmiosix_1_1_thread.html#af19b8a2ab852ea771a2e2b95bb0ba2a8">wakeup()</a> on a terminated thread, the behavior is undefined. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="acaef68f0e93f6ad933442d87c210daaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daaf">miosix::Thread::Options</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classmiosix_1_1_thread.html">Thread</a> options, can be passed to <a class="el" href="classmiosix_1_1_thread.html#ac5a454f2617a4a28f00842b1097fc363">Thread::create</a> to set additional options of the thread. More options can be specified simultaneously by ORing them together. The DEFAULT option indicates the default thread creation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="acaef68f0e93f6ad933442d87c210daafa03df086cf889e215d75222d10486b71e"></a>DEFAULT</em>&#160;</td><td class="fielddoc">
<p>Default thread options. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acaef68f0e93f6ad933442d87c210daafa785d69b0e6b95b648735efe54b588df7"></a>JOINABLE</em>&#160;</td><td class="fielddoc">
<p><a class="el" href="classmiosix_1_1_thread.html">Thread</a> is joinable instead of detached. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac5a454f2617a4a28f00842b1097fc363"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> * miosix::Thread::create </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>startfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Priority&#160;</td>
          <td class="paramname"><em>priority</em> = <code>Priority()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argv</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa03df086cf889e215d75222d10486b71e">DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Producer method, creates a new thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startfunc</td><td>the entry point function for the thread </td></tr>
    <tr><td class="paramname">stacksize</td><td>size of thread stack, its minimum is the constant STACK_MIN. The size of the stack must be divisible by 4, otherwise it will be rounded to a number divisible by 4. </td></tr>
    <tr><td class="paramname">priority</td><td>the thread's priority, between 0 (lower) and PRIORITY_MAX-1 (higher) </td></tr>
    <tr><td class="paramname">argv</td><td>a void* pointer that is passed as pararmeter to the entry point function </td></tr>
    <tr><td class="paramname">options</td><td>thread options, such ad <a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa785d69b0e6b95b648735efe54b588df7" title="Thread is joinable instead of detached. ">Thread::JOINABLE</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the thread created, that can be used, for example, to delete it, or NULL in case of errors.</dd></dl>
<p>Calls errorHandler(INVALID_PARAMETERS) if stacksize or priority are invalid, and errorHandler(OUT_OF_MEMORY) if the heap is full. Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a12d19634d30226cb4441a77b233a5bf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> * miosix::Thread::create </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>startfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Priority&#160;</td>
          <td class="paramname"><em>priority</em> = <code>Priority()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argv</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa03df086cf889e215d75222d10486b71e">DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as create(void (<em>startfunc)(void *), unsigned int stacksize, Priority priority=1, void *argv=NULL) but in this case the entry point of the thread returns a void</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startfunc</td><td>the entry point function for the thread </td></tr>
    <tr><td class="paramname">stacksize</td><td>size of thread stack, its minimum is the constant STACK_MIN. The size of the stack must be divisible by 4, otherwise it will be rounded to a number divisible by 4. </td></tr>
    <tr><td class="paramname">priority</td><td>the thread's priority, between 0 (lower) and PRIORITY_MAX-1 (higher) </td></tr>
    <tr><td class="paramname">argv</td><td>a void* pointer that is passed as pararmeter to the entry point function </td></tr>
    <tr><td class="paramname">options</td><td>thread options, such ad <a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa785d69b0e6b95b648735efe54b588df7" title="Thread is joinable instead of detached. ">Thread::JOINABLE</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the thread created, that can be used, for example, to delete it, or NULL in case of errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7817dd59f317a04d3ce3793419d25a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach the thread if it was joinable, otherwise do nothing.<br/>
 If called on a deleted joinable thread on which join was not yet called, it allows the thread's memory to be deallocated.<br/>
 If called on a thread that is not yet deleted, the call detaches the thread without deleting it. If called on an already detached thread, it has undefined behaviour. </p>

</div>
</div>
<a class="anchor" id="adb06c8f5761db66d1089a61db71dcf92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool miosix::Thread::exists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a thread exists </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>thread to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if thread exists, false if does not exist or has been deleted. A joinable thread is considered existing until it has been joined, even if it returns from its entry point (unless it is detached and terminates).</dd></dl>
<p>Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a884bfd106afeb274c339d383702b4aec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> * miosix::Thread::getCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the <a class="el" href="classmiosix_1_1_thread.html">Thread</a> class of the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the current thread.</dd></dl>
<p>Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="aacba6298a092d5335f6dbefe56a611ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Priority miosix::Thread::getPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the priority of a thread.<br/>
 To get the priority of the current thread use: </p>
<div class="fragment"><div class="line"><a class="code" href="classmiosix_1_1_thread.html#a884bfd106afeb274c339d383702b4aec">Thread::getCurrentThread</a>()-&gt;<a class="code" href="classmiosix_1_1_thread.html#aacba6298a092d5335f6dbefe56a611ec">getPriority</a>(); </div>
</div><!-- fragment --><p> If the thread is currently locking one or more mutexes, this member function returns the current priority, which can be higher than the original priority due to priority inheritance. </p>
<dl class="section return"><dt>Returns</dt><dd>current priority of the thread</dd></dl>
<p>Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a572b87e4c6174ad4137f964e40bbe515"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool miosix::Thread::IRQexists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classmiosix_1_1_thread.html#adb06c8f5761db66d1089a61db71dcf92">exists()</a> but is meant to be called only inside an IRQ or when interrupts are disabled. </p>

</div>
</div>
<a class="anchor" id="ae3918e86d91bbe3062f907004ba7f579"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> * miosix::Thread::IRQgetCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as get_current_thread(), but meant to be used insida an IRQ, when interrupts are disabled or when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a585c7966f59855aafd771c7733a38296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Priority miosix::Thread::IRQgetPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classmiosix_1_1_thread.html#aacba6298a092d5335f6dbefe56a611ec">getPriority()</a>, but meant to be used inside an IRQ, when interrupts are disabled or when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a6aed14f0f04e69f922aba8f0cf7ac0c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::IRQwait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classmiosix_1_1_thread.html#a435fe4527c1fdfcbebf886cd748a3fd4">wait()</a>, but is meant to be used only inside an IRQ or when interrupts are disabled.<br/>
 Note: this method is meant to put the current thread in wait status in a piece of code where interrupts are disbled; it returns immediately, so the user is responsible for re-enabling interrupts and calling yield to effectively put the thread in wait status.</p>
<div class="fragment"><div class="line"><a class="code" href="group___kernel.html#gacd7ef6e968c5c0b2ff45bf102388ea4d">disableInterrupts</a>();</div>
<div class="line">...</div>
<div class="line">Thread::IRQwait();<span class="comment">//Return immediately</span></div>
<div class="line"><a class="code" href="group___kernel.html#ga36adaaa176d004747d2a01b822c9fea5">enableInterrupts</a>();</div>
<div class="line"><a class="code" href="classmiosix_1_1_thread.html#a75823b1288a7defcb715fd6591a23b2d">Thread::yield</a>();<span class="comment">//After this, thread is in wait status</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab34c3cbac8aa609a5c6e4abc384a9faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::IRQwakeup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classmiosix_1_1_thread.html#af19b8a2ab852ea771a2e2b95bb0ba2a8">wakeup()</a>, but is meant to be used only inside an IRQ or when interrupts are disabled. </p>

</div>
</div>
<a class="anchor" id="afb1d97df689c7104bec35858bbaf4ae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool miosix::Thread::isDetached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the thread is detached </dd></dl>

</div>
</div>
<a class="anchor" id="a968b43a36ecdf124d72a5d8ddfa2a3b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool miosix::Thread::join </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>result</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait until a joinable thread is terminated.<br/>
 If the thread already terminated, this function returns immediately.<br/>
 Calling <a class="el" href="classmiosix_1_1_thread.html#a968b43a36ecdf124d72a5d8ddfa2a3b9">join()</a> on the same thread multiple times, from the same or multiple threads is not recomended, but in the current implementation the first call will wait for join, and the other will return false.<br/>
 Trying to join the thread join is called in returns false, but must be avoided.<br/>
 Calling join on a detached thread might cause undefined behaviour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>If the entry point function of the thread to join returns void *, the return value of the entry point is stored here, otherwise the content of this variable is undefined. If NULL is passed as result the return value will not be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a88af678dc4032a5f92da12917947d881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::PKwakeup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wakeup a thread. <br/>
Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="af6c4237506c533c00a0144632685b17d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::setPriority </td>
          <td>(</td>
          <td class="paramtype">Priority&#160;</td>
          <td class="paramname"><em>pr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the priority of this thread.<br/>
 This member function changed from previous Miosix versions since it is now static. This implies a thread can no longer set the priority of another thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pr</td><td>desired priority. Must be 0&lt;=pr&lt;PRIORITY_MAX</td></tr>
  </table>
  </dd>
</dl>
<p>Calls errorHandler(INVALID_PARAMETERS) if pr is not within bounds.</p>
<p>Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="ad7f738dc69a918960fe814a062696c5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put the thread to sleep for a number of milliseconds.<br/>
The actual precision depends on the kernel tick used. If the specified wait time is lower than the tick accuracy, the thread will be put to sleep for one tick.<br/>
Maximum sleep time is (2^32-1) / TICK_FREQ. If a sleep time higher than that value is specified, the behaviour is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>the number of millisecond. If it is ==0 this method will return immediately</td></tr>
  </table>
  </dd>
</dl>
<p>CANNOT be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="aac116a322826366c7b3269db3ab4be73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::sleepUntil </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>absoluteTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put the thread to sleep until the specified absolute time is reached. If the time is in the past, returns immediately. To make a periodic thread, this is the recomended way </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> periodicThread()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//Run every 90 milliseconds</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> period=<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code" href="group___settings.html#ga81e4cfce99dd185b6ada00ead4f39342">TICK_FREQ</a>*0.09);</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> tick=<a class="code" href="group___kernel.html#gad16c495ced6659e8bc0bb371362674ef">getTick</a>();</div>
<div class="line">    <span class="keywordflow">for</span>(;;)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Do work</span></div>
<div class="line">        tick+=period;</div>
<div class="line">        <a class="code" href="classmiosix_1_1_thread.html#aac116a322826366c7b3269db3ab4be73">Thread::sleepUntil</a>(tick);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">absoluteTime</td><td>when to wake up</td></tr>
  </table>
  </dd>
</dl>
<p>CANNOT be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="ae086b5bf2b3b55972ad696ec820c8f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suggests a thread to terminate itself. Note that this method only makes <a class="el" href="classmiosix_1_1_thread.html#a0ef492878827009d2d55442266d13b99">testTerminate()</a> return true on the specified thread. If the thread does not call <a class="el" href="classmiosix_1_1_thread.html#a0ef492878827009d2d55442266d13b99">testTerminate()</a>, or if it calls it but does not delete itself by returning from entry point function, it will NEVER terminate. The user is responsible for implementing correctly this functionality.<br/>
<a class="el" href="classmiosix_1_1_thread.html">Thread</a> termination is implemented like this to give time to a thread to deallocate resources, close files... before terminating. <br/>
Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a0ef492878827009d2d55442266d13b99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool miosix::Thread::testTerminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method needs to be called periodically inside the thread's main loop. </p>
<dl class="section return"><dt>Returns</dt><dd>true if somebody outside the thread called <a class="el" href="classmiosix_1_1_thread.html#ae086b5bf2b3b55972ad696ec820c8f5e">terminate()</a> on this thread.</dd></dl>
<p>If it returns true the thread must free all resources and terminate by returning from its main function. <br/>
Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a435fe4527c1fdfcbebf886cd748a3fd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method stops the thread until another thread calls <a class="el" href="classmiosix_1_1_thread.html#af19b8a2ab852ea771a2e2b95bb0ba2a8">wakeup()</a> on this thread.<br/>
Calls to wait are not cumulative. If <a class="el" href="classmiosix_1_1_thread.html#a435fe4527c1fdfcbebf886cd748a3fd4">wait()</a> is called two times, only one call to <a class="el" href="classmiosix_1_1_thread.html#af19b8a2ab852ea771a2e2b95bb0ba2a8">wakeup()</a> is needed to wake the thread. <br/>
CANNOT be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="af19b8a2ab852ea771a2e2b95bb0ba2a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::wakeup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wakeup a thread. <br/>
CANNOT be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a75823b1288a7defcb715fd6591a23b2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When called, suggests the kernel to pause the current thread, and run another one. <br/>
CANNOT be called when the kernel is paused. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>miosix/kernel/<a class="el" href="kernel_8h_source.html">kernel.h</a></li>
<li>miosix/kernel/kernel.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 31 2014 12:53:07 for STM32F4 Pedometer by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
